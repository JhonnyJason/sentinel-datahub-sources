{
    "name": "Conventions",
    "description": "# Understanding the API Structure\nThe Tradovate API is a low-level HTTP-based API that you can use to query data, submit orders, create alerts, receive notifications - almost everything that is available in the Tradovate Trader application.\n\nThe Tradovate REST API can be split into two parts: a set of endpoints to query data (typically `GET` method endpoints) and\nendpoints to modify (or submit) data (typically `POST` method endpoints). With rare exceptions, endpoint's paths consist of two parts:\nentity name and the operation type. For example, `/account/find` or `/order/cancelorder`.\n\nThe API exposes data with fine granularity to avoid limiting how applications would like\nto compose them. It is the responsibility of client applications to request all needed\ndependencies and join them. For example, to calculate your open P&L you would need to pull information from at least two domains - your positions data, and real-time market data for comparing those positions to live quotes.\n\n\n# Query Data\nQuery operations should use the HTTP GET method if called via REST API.\n\n## By ID\nAll entities that can be requested via API have unique IDs. `item` is an operation\nthat can be used to get an entity using that ID as a parameter. Here's an example of requesting an Order entity by ID in cURL:\n\n```\ncurl -X GET --header 'Accept: application/json' 'https://demo.tradovateapi.com/v1/order/item?id=1000'\n```\n\nSuch methods are translated to .NET reference API in the form `apiInstance.[Entity]Item(id)`:\n\n```c#\nAccount result = apiInstance.AccountItem(1000);\n```\n\nAnd in JavaScript we can use the `fetch` function:\n\n```js\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await fetch(URL + '/order/item?id=1000', {\n    headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n\nconst account = await response.json()\n```\n\nOr on Node JS we can use Axios:\n\n```js\nconst axios = require('axios')\n\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await axios.get(URL + '/position/item?id=1000', {\n    headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n```\n\n## All Entities at Once\nUsing the `/list` endpoint, we can retrieve all of the entities of a particular type. For example:\n\ncURL\n```\ncurl -X GET --header 'Accept: application/json' 'https://demo.tradovateapi.com/v1/fill/list'\n```\n\nAnd in C#:\n\n```c#\nList<Account> result = apiInstance.FillList();\n```\n\nIn JavaScript:\n\n```js\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await fetch(URL + '/fill/list', {\n   headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n\nconst fills = await response.json()\n```\n\n## Via Master-Details Dependency\nThe `deps` operation is intended to load only dependent or owned entities for another entity.\nThe `masterid` parameter should be an ID of `master` entity. For example, all positions\nthat are owned by an account with ID=123:\n\ncURL\n```\ncurl -X GET --header 'Accept: application/json' 'https://demo.tradovateapi.com/v1/position/deps?masterid=123'\n```\n\nC#:\n```c#\nList<Position> result = apiInstance.PositionDependents(accountId);\n```\n\nJS:\n```js\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await fetch(URL + '/position/deps?masterid=123', {\n    headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n\nconst result = await response.json()\n```\n\n## By name\nSome entities - like accounts, products, contracts, and currencies - have names. Here is\nan example of a `find` operation with the `name` parameter used to find a product with the name \"ES\":\n\ncURL:\n```\ncurl -X GET --header 'Accept: application/json' 'https://demo.tradovateapi.com/v1/product/find?name=ES'\n```\n\nC#:\n```c#\nProduct result = apiInstance.ProductFind(\"ES\");\n```\n\nJS:\n```js\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await fetch(URL + '/product/find?name=ES', {\n    headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n\nconst es = await response.json()\n```\n\n## Batch Loading\nThe Tradovate API exposes endpoints to load multiple entities in batch. It is more efficient to\nreplace multiple `item` operations for the same entity with one `items` operation and pass `ids` parameter\nas comma-separated list of IDs. Note: a number of loaded entities can be less than a number of IDs (in the case of an ID not found) and\na sequence of entities can be different than a sequence of IDs (we shouldn't expect data to be returned in the same order as it was requested). \n\ncURL:\n```\ncurl -X GET --header 'Accept: application/json' 'https://demo.tradovateapi.com/v1/contract/items?ids=840972%2C840944'\n```\n\nC#:\n```c#\nvar ids = new List<int?>();\n//...\nList<Contract> result = apiInstance.ContractItems(ids);\n```\n\nJS:\n```js\nconst URL = 'https://demo.tradovateapi.com/v1'\n\nconst response = await fetch(URL + '/contract/items?ids=840972%C840944', {\n    headers: {\n        Authorization: `Bearer ${myAccessToken}`,\n        'Content-Type': 'application/json'\n    }\n})\n\nconst contracts = await response.json()\n```\n\nSimilar batching can be applied to `deps` operations - it is faster to run the `ldeps`\noperation with the `masterids` to retrieve batched dependent entities.\n\n# Submit Data\nWhen using the REST API, the HTTP POST method should be used when we need to submit data. Data should be formatted as a valid JSON object\nand passed in the request body.\n\nThe naming conventions of these operations do not have any general rule and the name of each\noperation reflects the semantics behind its use. For example, `/order/placeorder` is used to make a request to place order and `/order/liquidateposition` is used to make a request to attempt to cancel all orders for a specified position.\n\nHere's a JS example of how to use the `placeOrder` endpoint with an HTTP POST request.\n```js\nconst URL = 'demo.tradovateapi.com/v1'\n\nconst body = {\n    accountSpec: yourUserName,\n    accountId: yourAcctId,\n    action: \"Buy\",\n    symbol: \"MYMM1\",\n    orderQty: 1,\n    orderType: \"Market\",\n    isAutomated: true //must be true if this isn't an order made directly by a human\n}\n\nconst response = await fetch(URL + '/order/placeorder', {\n    method: 'POST',\n    headers: {\n        'Accept': 'application/json',\n        'Authorization': `Bearer ${myAccessToken}`,\n    },\n    body: JSON.stringify(body)\n})\n\nconst json = await response.json() // { orderId: 0000000 }\n\n```\n\n# Error Handling\nThe Tradovate API has two paths by which to pass errors to the client - via HTTP status codes\nor via custom `errorText` fields in some endpoints. \n\nHTTP codes are used mostly in situations when required data or an operation is\nunavailable (404), inaccessible (401 or 403), or responds with Too Many Requests (429, 423). These are errors that prevent you from reaching an endpoint. \n\nThe `errorText` field in responses is used to describe business level violations in text format. This will happen in a situation where your request\nsucceeded at the HTTP level but server-side business logic constraints caused your request to be rejected. Usually there will be a description in the text that reflects what went wrong.\n\n# Automated Orders\nWhen placing an order via code or automated process (like with a trade bot perhaps), you **MUST** include the `isAutomated` flag in your request body. `isAutomated` defaults to false, which is what would be typical of an order placed by a human via click. However, if you were to place an order by bot or through some other algorithmic process, `isAutomated` has to be true. The exchange is _very serious_ about this requirement and failing to do so could violate exchange policies.\n\n# WebSockets Conventions\n## Clean up subscriptions\nWhen using websockets for real-time data, you should be aware of the requirement to clean up your subscriptions. With each real-time subscription (such as those created by requesting market data, or a chart) you will be given a subscription ID as a field on the data object. You should cache those IDs locally so that you can unsubscribe from those subscriptions later. Unsubscribing from a real-time data stream requires the real-time ID of that subscription as a parameter.\n> *Note*: You cannot unsubscribe from a `user/syncRequest` subscription other than by closing the connection. However, for the lifetime of your application you will likely not want to or need to unsubscribe from a `syncRequest`.\n\n## Use user/syncrequest\nWhen working with real-time user data, it is best practice to respond to the changes in user data. To do so, we make a request to `user/syncrequest` using a WebSocket. Every time a change occurs for the subscribed user, the linked Tradovate WebSocket Server will push updates to the client that subscribed via the `user/syncrequest` endpoint. These updates come in the form of messages, as described [here](/#section/Tradovate-Specific-Message-Types) This is intended to be called using a WebSocket, and not via HTTP. Permissions on your API Key may affect the available fields on the response object.\n\nSee Also: [`user/syncRequest`](/#operation/syncRequest) The response to this request details what the initial response from the server will look like. The individual entity types that you can receive updates for will have data that matches the interfaces listed in response object."
}