{
    "name": "Using Tick Charts",
    "description": "# Requesting Tick Charts\nTo get Tick Chart data, we can use the same process described in the [Market Data](/#tag/MarketData) section. Just like with Market Data, we need\nto open and authorize a WebSocket first. If you're following the [comprehensive JavaScript tutorial](https://github.com/tradovate/example-api-js),\nyou can find tick chart examples [here](https://github.com/tradovate/example-api-js/tree/main/tutorial/WebSockets/EX-11-Tick-Charts).\n\nJust like requesting regular chart data, we must construct a request body with the `symbol`, `chartDescription`,\nand `timeRange` fields. However, we need to lock `elementSize` to 1 and set `underlyingType` to `\"Tick\"`. For example:\n\n```js\n{\n  \"symbol\": \"ESU9\",\n  \"chartDescription\": {\n    \"underlyingType\": \"Tick\",\n    \"elementSize\": 1,\n    \"elementSizeUnit\": \"UnderlyingUnits\"\n  },\n  \"timeRange\": {\n    ...\n  }\n}\n```\n\nThen client then calls the standard `md/getChart` endpoint and passes the request to it. The Tradovate server responds with the standard JSON object schema\nfor chart data. Because an unsubscription request requires the real-time subscription ID sent with this response, the client should store the ID of each \nsubscription that they create so that they can properly unsubscribe later.\n\n# Data stream messages\n\nA typical data stream message has the following structure:\n\n```js\n{\n    \"charts\": [                     // Array of packets.\n        {\n            \"id\": 16335,            // Subscription ID, the same as historical/real-time subscription IDs from request response.\n            \"s\": \"db\",              // Source of packet data.\n            \"td\": 20210718,         // Trade date YYYYMMDD.\n            \"bp\": 11917,            // Base price of the packet (integer number of contract tick sizes).\n                                    // Tick prices are calculated as relative from this one.\n            \"bt\": 1563421179735,    // Base timestamp of the packet.\n                                    // Tick timestamps are calculated as relative from this value.\n            \"ts\": 0.25,             // Tick size of the contract for which the tick chart is requested.\n            \"tks\": [                // Array of ticks of this packet.\n                {\n                    \"t\": 0,         // Tick relative timestamp.\n                                    // Actual tick timestamp is packet.bt + tick.t\n                    \"p\": 0,         // Tick relative price (in contract tick sizes).\n                                    // Actual tick price is packet.bp + tick.p\n                    \"s\": 3,         // Tick size (seems more proper name should be tick volume).\n                                    // Please don't confuse with contract tick size (packet.ts).\n                    \"b\": -1,        // Bid relative price (optional).\n                                    // Actual bid price is packet.bp + tick.b\n                    \"a\": 0,         // Ask relative price (optional).\n                                    // Actual ask price is packet.bp + tick.a\n                    \"bs\": 122.21,   // Bid size (optional).\n                    \"as\": 28.35,    // Ask size (optional).\n                    \"id\": 11768401  // Tick ID\n                },\n                ...\n            ]\n        },\n        // Multiple packets are possible...\n        {\n            \"id\": 16335,\n            eoh: true               // End of history flag.\n                                    // If the request time range assumes historical data,\n                                    // this flag indicates that historical ticks are loaded and\n                                    // further packets will contain real-time ticks.\n        }\n    ]\n};\n```\n\n## Using the Tick Stream\nThe following code snippet is an example of how to process tick chart data stream messages and calculate actual ticks for client consumption.\n\nThe function takes a data stream message and converts its packets into a list of actual ticks. Usage of this function assumes that you'll be passing\nit the message data retrieved from the WebSocket. Because tick stream data can arrive out of chronological order, it is the client's responsibility to \nstore and sort pertinent portions of this data.\n\n```js\nfunction processTickChartMessage(msg) {\n    const result = [];\n    if (msg.charts && msg.charts.length) {\n        for (let i = 0; i < msg.charts.length; ++i) {\n            const packet = msg.charts[i];\n            if (packet.eoh) { //end-of-history,\n                // Historical ticks are loaded.\n            }\n            else if (packet.tks && packet.tks.length) {\n                for (let j = 0; j < packet.tks.length; ++j) {\n                    const tick = packet.tks[j];\n\n                    const timestamp = packet.bt + tick.t;   // Actual tick timestamp\n                    const price = packet.bp + tick.p;       // Actual tick price\n\n                    const bid = tick.bs && (packet.bp + tick.b);    // Actual bid price (if bid size defined)\n                    const ask = tick.as && (packet.bp + tick.a);    // Actual ask price (if ask size defined)\n\n                    result.push({\n                        id: tick.id,\n                        timestamp: new Date(timestamp),\n\n                        price: price * packet.ts,           // Tick price as contract price\n                        size: tick.s,                       // Tick size (tick volume)\n\n                        bidPrice: bid && (bid * packet.ts), // Bid price as contract price\n                        bidSize: tick.bs,\n\n                        askPrice: ask && (ask * packet.ts), // Ask price as contract price\n                        askSize: tick.as,\n                    });\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n"
}