{
    "name": "WebSockets",
    "description": "# Connecting to the WebSocket Server\nThe current version of our WebSocket-based protocol is inherited from [SockJS protocol](http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-42) which was used in earlier versions. For the WebSockets section of the comprehensive JavaScript guide to the Tradovate API, go [here](https://github.com/tradovate/example-api-js/tree/main/tutorial/WebSockets/EX-05-WebSockets-Start). For the C# sample project, go [here](https://github.com/tradovate/example-api-csharp-trading) \n\nYou'll need to create a WebSocket instance using one of the real-time API URL's. However, instead of using the `https://` prefix we will\nneed to use the `wss://` WebSocket protocol prefix. Here's an example using our demo API URL:\n\n`wss://demo.tradovateapi.com/v1/websocket`\n\n# Server Frames\nThe WebSocket server communicates in _frames_. A frame consists of two parts - a 'type' prefix character and an array of JSON data. These two parts are concatenated into a string, and we will be responsible for creating the logic to deconstruct such messages on the client. The following are the message types supported and sent by the Tradovate WebSocket:\n\n\n- `'o'`: Open frame. Every time a new session is established, the server must immediately send the open frame. This is required, as some protocols (mostly polling) can't distinguish between a properly established connection and a broken one - we must convince the client that it is indeed a valid URL and it can be expecting further messages in the future via that URL.\n\n- `'h'`: Heartbeat frame. Most loadbalancers have arbitrary timeouts on connections. In order to keep connections from breaking, the server must send a heartbeat frame every now and then. The server sends a heartbeat about every 2.5 seconds, and to keep the connection alive the client must also send a response beat in the form of an empty array, stringified (`'[]'`)\n\n- `'a'`: A string containing an Array of JSON-encoded messages. For example: `'a[{\"data\": \"value\"}]'`.\n\n- `'c'`: Close frame. This frame is send to the browser every time the client asks for data on closed connection. This may happen multiple times. Close frame contains a code and a string explaining a reason of closure, like: `c[3000, \"Go away!\"]`.\n\n## Decoding Server Frames\n\nTradovate uses 'a' frames as a backbone for its own message protocol. Below are a few bits of example data.\n```\na[{\"s\":200,\"i\":23,\"d\":{\"id\":65543,\"name\":\"CLZ6\",\"contractMaturityId\":6727}}]\na[{\"e\":\"props\",\"d\":{\"entityType\":\"order\",\"eventType\":\"Created\",\"entity\":{\"id\":210518,\"accountId\":25,\"contractId\":560901,\"timestamp\":\"2016-11-04T00:02:36.626Z\",\"action\":\"Sell\",\"ordStatus\":\"PendingNew\",\"admin\":false}}}]\n```\n\nYou can quickly parse frames into more consumable data using a function such as the `prepareMsg` example below. It will turn the string message into a tuple that you can destructure.\n\n```js\nfunction prepareMsg(raw) {\n    const T = raw.slice(0, 1)\n    let payload = null\n    const data = raw.slice(1)\n    if(data) {\n        payload = JSON.parse(data)\n    }\n    return [T, payload]\n}\n\n//usage:\nmySocket.onmessage = msg => {\n    //data may be null\n    const [T, data] = prepareMsg(msg.data)\n    switch(T) {\n        case 'a': {\n            //react to data\n            break\n        }\n    }\n}\n```\n\n# Tradovate-Specific Message Types\nThe Tradovate Socket Servers interact with WebSocket clients by sending messages. The data portion of these messages is always an array of JSON objects. There are two main categories of messages that the Tradovate Servers will send - server events and responses to client request.\n\n## Server Event Message\nAn event message has the following structure:\n\n```\n{\n  \"e\":\"props\",\n  \"d\":{\n    \"entityType\":\"order\",\n    \"eventType\":\"Created\",\n    \"entity\":{\n      \"id\":210518,\n      \"accountId\":25,\n      \"contractId\":560901,\n      \"timestamp\":\"2016-11-04T00:02:36.626Z\",\n      \"action\":\"Sell\",\n      \"ordStatus\":\"PendingNew\",\n      \"admin\":false\n    }\n  }\n}\n```\n\nThe `\"e\"` field specifies an event kind:\n- `\"props\"`: this is a notification that some entity was created, updated or deleted. \"d\" field specifies details of the event with the next structure:\n  * `\"entityType\"` field\n  * `\"entity\"` field. JSON structure of object (or array of objects) specified in this field is identical to JSON of entity that accessible via corresponding REST API request like *entityType*/item. For example, if entityType=account, JSON can be found in the [response specification of account/item call](/#operation/accountItem)\n  * `\"eventType\"` field with options \"Created\", \"Updated\" or \"Deleted\"\n- `\"shutdown\"`: a notification before graceful shutdown of connection. \"d\" field specifies details:\n  * `\"reasonCode\"` field with options \"Maintenance\", \"ConnectionQuotaReached\", \"IPQuotaReached\"\n  * `\"reason\"` field is optional and may contain a readable explanation\n- `\"md\"` and \"chart\": these notifications are used by market data feed services only, the description of \"d\" field is [here](/#tag/MarketData)\n- `\"clock\"`: Market Replay clock synchronization message. See the [Market Replay](/#section/Request-Examples/Market-Replay) section below.\n\n## Response Message\n\nA response message is issued when a client makes a request. These messages are intended to mimic REST API responses and have the following structure:\n\n```\n{\n  \"i\":26,\n  \"s\":200,\n  \"d\":{\n    \"id\":478866,\n    \"name\":\"6EZ6\",\n    \"contractMaturityId\":23574\n  }\n}\n```\n- `\"i\"` field is a id of corresponding client request (see \"Client requests\" below). A responses id will always match the id of the request that generated it.\n- `\"s\"` field is a HTTP status code of response\n- `\"d\"` field is a content of response. If HTTP status is 2xx, this field contains JSON response as defined in Swagger specification of the corresponding request. Otherwise, `\"d\"` is a string representation of error text.\n\n# Client Requests\nSockJS doesn't define framing for client requests. For this reason, we use standard text for our client request protocol.\n\nEach frame sent by the client contains exactly one request. The frame consists of four fields:\n- An endpoint name as defined in the spec. These are any of the endpoints that you could request from the standard REST API.\n- A unique integer ID of the request. The ID should be unique in the scope of the current connection. This ID will be used as a reference by the server in\nthe response messages (see \"Response Message\" above)\n- an optional field with parameters identical to query parameters of REST API\n- an optional field that is identical to a body parameter of REST API\n\nThe four fields _must be_ separated by the `'\\n'` (\"new line\") character. This is how message parameters are delimited when they get decoded.\n\n\n## Request Examples\nAn example of a request without query or body:\n\n```\nexecutionReport/list\n4\n\n```\n\nAn example of a request with a query parameter:\n\n```\ntradingPermission/ldeps\n8\nmasterids=1\n```\n\nAn example of a request with a body:\n\n```\ncontract/rollcontract\n33\n\n{\"name\":\"YMZ6\",\"forward\":true,\"ifExpired\":true}\n```\n\n# Authorization\nBecause WebSocket is a permanent connection, it is sufficient to authorize the connection just once per application instance.\nWe use a special request with the `authorize` endpoint and an access token in in the message body.\n\n```\nauthorize\n2\n\nuST01MhJMF3cR3lCs-gdQ9W0AzomYLaqsWcZ_GYgAspPRf-ZS-Wb7q3sW3pUafTm90ba4\n```\nDon't forget to add the newline in between parameters.\nA successful response will look like this, were `s` represents the status code (200 here) and `i` is the ID of the request sent:\n\n```\na[{\"s\":200,\"i\":2}]\n```\n\n# User Synchronization\nOnce you've opened a real-time connection via WebSocket, it is a good idea to synchronize your user data. Using the `user/syncrequest` endpoint will allow us to get an update with any data changes that pertain to your user. This is the core of digesting real-time data about your user, like calculating profits and losses, or getting a snapshot of your current margins. For more information on the response object, see the [syncRequest operation](/#operation/syncRequest). Remember that this endpoint is intended for use via WebSocket. \n> Keep in mind that the fields present on the response object of a `'user/syncrequest'` may be affected by your API Key's permissions settings.\n\n# Market Replay\nMarket Replay service follows the same protocols for trading and market data as regular Tradovate services. \n\nHostnames: `wss://replay.tradovateapi.com/v1/websocket`\n\nThe client application should set initial parameters for replay session right after successful authorization. The request should be formatted like any other client request. The endpoint name of the request should be `replay/initializeclock`. Parameters:\n* `startTimestamp`: start time of the session\n* `speed`: speed of replaying in percents. The valid range is 0-400 \n* `initialBalance`: a dollar amount of replay account. The account will be created automatically with the specified cash balance and will be discarded at the end of the replay session.\n\nExample:\n\n```\nreplay/initializeclock\n3\n\n{\"startTimestamp\":\"2019-08-26T16:43:00.000Z\",\"speed\":20,\"initialBalance\":51000}\n```\n\nThe response will indicate if a session started successfully:\n\n```\na[{\"s\":200,\"i\":3,\"d\":{\"ok\":true}}]\n```\n\nThere is allowed only one replay session per user. An attempt to initialize a new session will reset the currently running one. Multiple connections can join to the same session. A lack of initialization request is treated as a joining to existing one.\n\nTo maintain the clock synchronization between the server-side 'replay' clock and the client clock, the server pushes periodical clock synch event messages like this:\n\n```\na[{\"e\":\"clock\",\"d\":\"{\\\"t\\\":\\\"2019-08-26T16:43:08.599Z\\\",\\\"s\\\":20}\"}]\n```\n\n`d` field contains a text representation of JSON entity with the next fields:\n- `t`: the current replay timestamp\n- `s`: the current replay speed\n\nThe clock event can typically be used to determine whether your replay session has reached a certain time. It is also useful to know when the server has limited your speed, in which case you'll need to send a request to change the replay speed, mentioned below.\n\nThe client app can control the speed of the replay session via `replay/changespeed` request. The request should include `speed` parameter with a range from 0 to 400 (in percents), 400 being 4X the real-time speed of the market.\n\nExample:\n```\nreplay/changespeed\n49\n\n{\"speed\":100}\n```\n\nSometimes the server will pause your replay. In this case, the client will continue to receive clock synch messages with `speed` field equals to 0. The client app can unpause it via `replay/changespeed` request.\n\nThe session is discarded automatically when there are no connections associated with it.\n\nDepending on the customer's entitlements, Market Replay functionality can be limited or disallowed at all. To check if a picked date/time is permitted for the user, the client app can use the next REST API call [replay/checkReplaySession](/#operation/checkReplaySession) before initiating replay connection.\n\n\n## Client Heartbeats\nEven WebSockets have built-in pings. As mentioned in the [Server Frames](/#tag/WebSockets#Server-Frames) section, a client is responsible to send heartbeats every 2.5 seconds to avoid closing by server due to inactivity. A heartbeat should be a frame with \"[]\" (empty array) as its text, which you can send using the `WebSocket.send` method. It is best to adopt a mechanism that doesn't rely on `setInterval` when developing for web - this function can be throttled by the browser leading to disconnection ultimately. Instead generate a timestamp (`new Date()` will do) with each received message. Check that against the timestamp of the last message received, and if the time has exceeded 2500ms send a heartbeat frame. You can find an example of how to do this [here](https://github.com/tradovate/example-api-js/tree/main/tutorial/WebSockets/EX-06-Heartbeats).\n> Note: A server that is actively streaming live data (such as a market data subscription) will not send heartbeats while outputting messages. So long as the developer ensures that the client sends heartbeats every 2.5 seconds, the connection will stay alive.\n\n## Reference implementations\nWe have reference projects for both C# and JavaScript users. You can find the C# project [here](https://github.com/tradovate/example-api-csharp-trading), and the JavaScript tutorial [here](https://github.com/tradovate/example-api-js).\n"
}